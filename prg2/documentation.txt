1. About the data structure
The data structure I selected to store stops and routes is unordered_map because no operation requires printing stopid/routeid in alphabetical order. There is also an unordered_map, allTrips, storing stopid and correspondind edge and arrival time. If the key is stopid(from_stop) then the edge in map.values should include 4 informations: to_stop, route_id, distance between from_stop and to_stop, time_pair(departure time from from_stop and arrival time to to_stop). But I didn't put time and distance in one struct Edge because in trip-operations, only considering the route added time info. Then if I put the both time and distance a struct Edge, I need to check if a route has time in trip operations.

2. About the algorithm used in finding journey
In journey_any, I used the DFS algorithm because generally, there are many stops between fromstop and tostop, so the tostop is probably in the deeper level not shallower level. And with DFS algorithm, We can detect the circle case and we can find the shortest path with BFS algorithm. Then I implement DFS in journey_circle and BFS in journey_least_stops. The algorithm I leveraged in operation journey_shortest_distance and journey_earilest_time is Dijkstra algorithm. So the estimated performances of these operations are similiar to the corresponding algorithms. Generally, operation journey_shortest_distance and journey_earilest_time are similiar, and the value compared in priority_queue in operation shortest_distance is total distance while the value is arrival time in operation earilest_time. Additionally, the difference between two operations is that the distance between two stops is constant, but time is not because there are more than one time tables in a route. Thus, the additional operation in earilest_time is finding the time(departure time of the last stop and arrival time of the next stop).
